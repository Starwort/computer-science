<!DOCTYPE html>
<html>

<head>
    <!-- make markdown look nicer -->
    <style>
        code {
            background-color: rgba(27, 31, 35, .05);
            border-radius: 3px;
            font-size: 85%;
            margin: 0;
            padding: .2em .4em;
        }

        pre code {
            background-color: rgba(27, 31, 35, .05);
            border: 0;
            display: block;
            line-height: inherit;
            margin: 0;
            max-width: auto;
            overflow: scroll;
            padding: 0;
            word-wrap: normal;
        }
    </style>
</head>
<body><h1 id="processor-architectures">Processor Architectures</h1>
<h2 id="the-stored-program-concept">The stored program concept</h2>
<ul>
<li>Instructions and data are stored in memory for the program to be executed
<ul>
<li>Fetch-Decode-Execute, millions of times per second</li>
</ul></li>
<li>E.G. game on disc being loaded onto a console:
<ul>
<li>Insert a disc (secondary storage)</li>
<li>Disc spins up, system loads content to RAM</li>
<li>Game plays - instructions executed and data loaded from RAM</li>
</ul></li>
</ul>
<h2 id="addressable-memory">Addressable memory</h2>
<ul>
<li>Memory
<ul>
<li>Made up of millions of addressable cells (with unique addresses)</li>
<li>Holds instructions and data of programs</li>
<li>CPU retrieves instructions and data from cells (with the data and address buses) and executes them</li>
</ul></li>
<li>Blocks of memory addresses allocated to different programs in a systematic way
<ul>
<li>Operating System</li>
<li>Application software</li>
<li>CPU can find instructions and data with fewer cyucles than if stored randomly</li>
<li>Addresses normally written in hex</li>
</ul></li>
</ul>
<h2 id="von-neumann-vs-harvard-architectures">Von Neumann vs Harvard Architectures</h2>
<ul>
<li>Architecture refers to the way something is built (such as the CPU)</li>
</ul>
<h3 id="von-neumann">Von Neumann</h3>
<ul>
<li>Instructions and data are stored in RAM and are moved in and out through the data bus</li>
</ul>
<h4 id="bottleneck">Bottleneck</h4>
<ul>
<li>If instructions are to perform operations on data in memory:
<ul>
<li>data has to move across the data bus into the CPU</li>
<li>when the computation is done, the results travel back to memory across the same bus</li>
</ul></li>
<li>If the processor has just finished an instruction and is ready to perform the next, it may have to write the finished computation into memory (occupying the data bus) before it can fetch its next instruction</li>
<li>Bottleneck has increased over time because processors have improved in speed but memory has not progressed as fast.</li>
<li>Some techniques to reduce the impact of the bottle neck are to keep memory in cache to minimise data movement</li>
</ul>
<pre><code>+---------+      +---------------+      +---------+
|  Input  | ___\ | CPU  [CU ALU] | ___\ | Output  |
| Devices |    / |  Memory Unit  |    / | Devices |
+---------+      +---------------+      +---------+</code></pre>
<h4 id="typical-use-case">Typical use case</h4>
<ul>
<li>Most general purpose computers use this architecture</li>
<li>Some embedded systems use this
<ul>
<li>generally if control-functions only</li>
</ul></li>
</ul>
<h3 id="harvard">Harvard</h3>
<ul>
<li>Separate buses are used for data and instructions
<ul>
<li>Linked to different memories - instruction memory and data memory
<ul>
<li>Instructions and data are handled more quickly as they do not share the same bus</li>
<li>Programs run faster / more efficiently</li>
<li>Able to run a program and access data independently and therefore simultaneously</li>
<li>Strict separation between data and code</li>
</ul></li>
</ul></li>
<li>More complicated but removes the bottleneck that Von Neumann creates</li>
</ul>
<pre><code>                           ALU
                            ^
                            v
Instruction Memory &lt;-&gt; Control Unit &lt;-&gt; Data Memory
                            ^
                            v
                        IO Devices</code></pre>
<h4 id="typical-use-case-1">Typical use case</h4>
<ul>
<li>Used on some embedded systems or microcontrollers
<ul>
<li>For real-time data</li>
<li>Instructions can often be held in read-only memory as they often do not need to be changed</li>
<li>Data memory requires read-write memory</li>
<li>Some systems have more instruction memory than data memory so the instruction addresses and buses are wid than data addresses and bus</li>
</ul></li>
<li>Used for Digital Signal Processing (DSP)
<ul>
<li>takes real-world signals like voice, audio, video, temperature, pressure, or position that have been digitised, and mathematically manipulate them</li>
<li>e.g. navigation systems, trafic lights, aircraft flight control systems and simulators</li>
</ul></li>
</ul>
<h3 id="comparison">Comparison</h3>
<table style="width:14%;">
<colgroup>
<col width="6%" />
<col width="6%" />
</colgroup>
<thead>
<tr class="header">
<th align="right">Von Neumann</th>
<th align="right">Harvard</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">Data and programs share the same memory</td>
<td align="right">Instructions and data are held in separate memories</td>
</tr>
<tr class="even">
<td align="right">One bus is used to transfer data and instructions</td>
<td align="right">Parallel data and instructionbuses may be used</td>
</tr>
<tr class="odd">
<td align="right">Programs can be optimised in size</td>
<td align="right">Programs tend to be large</td>
</tr>
</tbody>
</table>
<p>Modern high-performance CPU chips incorporate aspects of both Von Neumann and Harvard architectures - RAM holds both data and instructions (Von Neumann) - CPU cache divided into instruction cache and data cache (Harvard)</p>
</body>
</html>
